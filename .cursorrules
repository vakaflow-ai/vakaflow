# VAKA Agent Platform - Coding Standards & Best Practices

## Core Principles
- **Maintainability**: Code should be easy to understand, modify, and extend
- **Usability**: User experience is paramount - intuitive, responsive, accessible
- **Security**: Security by design - never trust user input, always validate
- **Performance**: Optimize for both developer and runtime performance
- **Scalability**: Design for growth - handle increased load gracefully
- **Reliability**: Fail gracefully, provide clear error messages, log appropriately

## Code Organization

### Backend (Python/FastAPI)
- Use **service layer pattern** - business logic in services, not API routes
- API routes should be thin - delegate to services
- Use type hints for all functions
- Use Pydantic models for request/response validation
- Handle errors with appropriate HTTP status codes
- Log errors with context (user_id, tenant_id, etc.)
- Never expose internal errors to clients

### Frontend (TypeScript/React)
- Use **custom hooks** to extract business logic from components
- Keep components focused (single responsibility)
- Use React Query for server state
- Use useState for local UI state
- Extract reusable components
- Limit component size (< 300 lines)
- Use React.memo, useMemo, useCallback appropriately

## Security Standards

### Input Validation
- ✅ Always validate and sanitize all user inputs
- ✅ Use type-safe schemas (Pydantic for backend, Zod for frontend)
- ✅ Validate on both client and server (defense in depth)
- ✅ Never trust client-side validation alone

### Authentication & Authorization
- ✅ Use JWT tokens with appropriate expiration
- ✅ Implement role-based access control (RBAC)
- ✅ Enforce tenant isolation for multi-tenant data
- ✅ Use dependency injection for permission checks

### Tenant Isolation & Data Segregation (CRITICAL - NO EXCEPTIONS)
**MANDATORY RULE: ALL data MUST be tenant-isolated. Cross-tenant data leaks are a CRITICAL security vulnerability.**

#### Core Principles
- ✅ **NEVER** access data without filtering by `tenant_id`
- ✅ **ALWAYS** use `current_user.tenant_id` from authenticated user (never trust client-provided tenant_id)
- ✅ **ALWAYS** validate `tenant_id` matches `current_user.tenant_id` before returning data
- ✅ **NEVER** allow users to access/modify data from other tenants
- ✅ **PLATFORM ADMIN EXCEPTION**: Only `platform_admin` can access cross-tenant data (with explicit `tenant_id` parameter and proper authorization checks)

#### Data Types That MUST Be Tenant-Isolated
1. **Tenant Settings & Configuration**
   - `Tenant.custom_branding` (logo, colors, branding)
   - `Tenant.settings` (tenant-specific settings)
   - `Tenant.industry`, `Tenant.timezone`, `Tenant.locale`, `Tenant.i18n_settings`
   - All tenant profile data

2. **Agents**
   - All `Agent` records MUST be filtered by tenant (through `Vendor.tenant_id`)
   - Agent queries: `Agent.vendor_id.in_(vendor_ids)` where vendors filtered by `tenant_id`
   - Agent metadata, artifacts, connections - all tenant-isolated

3. **Dashboard & Analytics**
   - All dashboard data MUST filter by `current_user.tenant_id`
   - Analytics queries MUST include tenant filter
   - Reports MUST be tenant-scoped

4. **Vendors**
   - All `Vendor` records MUST have `tenant_id` and be filtered by it
   - Vendor queries: `.filter(Vendor.tenant_id == current_user.tenant_id)`

5. **Users**
   - User queries MUST filter by `tenant_id` (except platform_admin)
   - User management MUST be tenant-scoped

6. **Assessments & Evaluations**
   - All assessment data MUST be tenant-isolated
   - Assessment templates filtered by tenant industry

7. **Compliance & Requirements**
   - Compliance frameworks filtered by tenant industry
   - Submission requirements filtered by tenant industry

8. **Workflows & Reviews**
   - Workflow configurations tenant-scoped
   - Reviews filtered by tenant through agents/vendors

9. **Integrations**
   - Integration configurations tenant-specific (with platform fallback)
   - SMTP, SSO, webhooks - all tenant-isolated

10. **Reports & Exports**
    - All reports MUST be tenant-scoped
    - Export data MUST filter by tenant_id

#### Query Patterns (MANDATORY)

**✅ CORRECT Patterns:**
```python
# Direct tenant filtering
tenant = db.query(Tenant).filter(Tenant.id == current_user.tenant_id).first()
if not tenant or tenant.id != current_user.tenant_id:
    raise HTTPException(404, "Tenant not found")

# Agents through vendors
vendors = db.query(Vendor).filter(Vendor.tenant_id == current_user.tenant_id).all()
vendor_ids = [v.id for v in vendors]
agents = db.query(Agent).filter(Agent.vendor_id.in_(vendor_ids)).all()

# Direct tenant_id filtering
users = db.query(User).filter(User.tenant_id == current_user.tenant_id).all()

# Dashboard/analytics with tenant filter
if current_user.role.value == "tenant_admin" and current_user.tenant_id:
    vendors = db.query(Vendor).filter(Vendor.tenant_id == current_user.tenant_id).all()
    vendor_ids = [v.id for v in vendors]
    agent_query = agent_query.filter(Agent.vendor_id.in_(vendor_ids))

# Using helper functions for tenant validation (RECOMMENDED)
# Example: validate_agent_tenant_access(agent, current_user, db)
# This ensures consistent tenant isolation across all endpoints
```

**❌ WRONG Patterns (SECURITY VULNERABILITIES):**
```python
# Missing tenant filter
agents = db.query(Agent).all()  # ❌ LEAKS ALL TENANTS' DATA

# Trusting client-provided tenant_id
tenant = db.query(Tenant).filter(Tenant.id == request.tenant_id).first()  # ❌ NEVER TRUST CLIENT

# Missing validation
tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
return tenant  # ❌ Missing validation that tenant.id == current_user.tenant_id

# Platform admin without explicit check
if current_user.role.value == "platform_admin":
    return db.query(Agent).all()  # ❌ Should still require explicit tenant_id parameter
```

#### Helper Functions (RECOMMENDED)
Create reusable helper functions for tenant validation:
```python
def validate_agent_tenant_access(agent: Agent, current_user: User, db: Session) -> None:
    """Validate tenant access to agent - raises HTTPException if denied"""
    # Platform admins can access all
    if current_user.role.value == "platform_admin":
        return
    # Validate through vendor.tenant_id
    vendor = db.query(Vendor).filter(Vendor.id == agent.vendor_id).first()
    if vendor.tenant_id != current_user.tenant_id:
        raise HTTPException(403, "Access denied: Different tenant")
```

#### Validation Checklist (MANDATORY FOR ALL ENDPOINTS)
Before returning any data, verify:
- [ ] Query filters by `current_user.tenant_id` (or through related models)
- [ ] For tenant-specific endpoints, validate `resource.tenant_id == current_user.tenant_id`
- [ ] Use helper functions (e.g., `validate_agent_tenant_access`) for consistent validation
- [ ] Platform admin endpoints require explicit `tenant_id` parameter
- [ ] No client-provided `tenant_id` is trusted without validation
- [ ] All related data (agents, vendors, users) is tenant-scoped
- [ ] Dashboard/analytics queries include tenant filters
- [ ] Reports and exports are tenant-scoped
- [ ] Agent detail endpoints validate tenant access (not just vendor_user)

#### Audit & Logging
- ✅ Log all tenant data access with `tenant_id` for security auditing
- ✅ Log cross-tenant access attempts (security alerts)
- ✅ Include `tenant_id` in audit logs for all data operations

### Data Protection
- ✅ Hash passwords with bcrypt (never store plaintext)
- ✅ Use parameterized queries (SQLAlchemy ORM prevents SQL injection)
- ✅ Sanitize output to prevent XSS
- ✅ Never log sensitive data (passwords, tokens, PII)

## Integration Standards

### Integration-First Architecture
- ✅ **ALWAYS use Integration APIs** - Never use local/hardcoded files, scripts, or environment variables for integration configuration
- ✅ **Single Source of Truth** - All integration configurations (SMTP, SSO, webhooks, etc.) must be stored in the `/integrations` database table
- ✅ **No Hardcoded Configs** - Never hardcode API keys, endpoints, credentials, or connection strings in code
- ✅ **No Local Files** - Never read configuration from local files, `.env` files, or hardcoded scripts
- ✅ **Integration APIs Only** - Always use `/api/v1/integrations` endpoints to retrieve and manage integration configurations
- ✅ **Service Layer** - Services must load configuration from Integration model via database queries, not environment variables
- ✅ **Tenant Isolation** - Support tenant-specific integrations with fallback to platform-wide integrations
- ✅ **Error Handling** - If integration not found, return clear error: "Please configure [integration_type] in /integrations page"

**Examples:**
- ❌ **WRONG**: `os.getenv("SMTP_HOST")`, hardcoded credentials, local config files
- ✅ **CORRECT**: Query `Integration` table, use `IntegrationService`, load from database

**Integration Types:**
- SMTP Email → `/integrations` page → `Integration.integration_type == "smtp"`
- SSO → `/integrations` page → `Integration.integration_type == "sso"`
- Webhooks → `/integrations` page → `Integration.integration_type == "webhook"`
- All external services → `/integrations` page → Stored in `Integration` table

## Code Quality

### Naming Conventions
- **Python**: Classes `PascalCase`, functions `snake_case`, constants `UPPER_SNAKE_CASE`
- **TypeScript**: Components `PascalCase`, functions `camelCase`, constants `UPPER_SNAKE_CASE`
- Use descriptive names that explain intent
- Avoid abbreviations unless widely understood

### Comments & Documentation
- Explain WHY, not WHAT (code should be self-documenting)
- Document complex business logic
- Use docstrings for public functions/classes
- Keep comments up to date with code changes

### Error Handling
- Handle all error states (loading, error, success)
- Provide user-friendly error messages
- Log errors for debugging
- Use appropriate HTTP status codes
- Never expose stack traces to clients

## Database Standards

### Schema Design
- Use UUIDs for primary keys
- Add indexes on foreign keys and frequently queried columns
- Use appropriate data types
- Add NOT NULL constraints where appropriate
- Use database-level constraints (unique, foreign key)

### Migrations
- Always use Alembic for schema changes
- Never modify existing migrations (create new ones)
- Test migrations on staging before production
- Make migrations reversible (implement downgrade)

## API Design

### RESTful Design
- Use appropriate HTTP methods (GET, POST, PUT, PATCH, DELETE)
- Use proper status codes (200, 201, 400, 401, 403, 404, 500)
- Use consistent URL patterns
- Version APIs (`/api/v1/...`)
- Use plural nouns for resources

### Request/Response Validation
- Use Pydantic models for all request/response schemas
- Validate all inputs
- Return consistent response formats
- Include error details in error responses

## Frontend Standards

### Component Structure
- Use functional components with hooks
- Keep components focused (single responsibility)
- Extract reusable logic into custom hooks
- Use composition over prop drilling
- Limit component size (aim for < 300 lines)

### State Management
- Use React Query for server state
- Use useState for local UI state
- Use Context for shared state (sparingly)
- Keep state as local as possible

### Performance Optimization
- Use React.memo for expensive components
- Use useMemo for expensive calculations
- Use useCallback for event handlers passed to children
- Lazy load routes and heavy components
- Virtualize long lists
- Debounce search inputs

### Accessibility (a11y)
- Use semantic HTML elements
- Provide ARIA labels for interactive elements
- Ensure keyboard navigation works
- Maintain proper focus management
- Provide alt text for images
- Ensure sufficient color contrast (WCAG 2.1 Level AA)

## Testing Standards

### Test Coverage
- Aim for >80% code coverage
- Test critical business logic
- Test error cases
- Test edge cases
- Use integration tests for API endpoints

### Test Organization
- Follow Arrange-Act-Assert pattern
- Use descriptive test names
- Keep tests independent
- Use fixtures for common setup

## Documentation Standards

### Code Documentation
- Document all public functions/classes with docstrings
- Include parameter and return type documentation
- Add examples for complex functions
- Keep documentation up to date

### API Documentation
- Use FastAPI's automatic OpenAPI documentation
- Add descriptions to endpoints
- Include example requests/responses
- Document error responses

## Performance Standards

### Backend Performance
- Use database indexes for frequently queried fields
- Avoid N+1 queries (use eager loading)
- Implement caching where appropriate
- Use connection pooling
- Optimize database queries

### Frontend Performance
- Lazy load routes and components
- Code split by route
- Optimize images (use WebP, lazy load)
- Minimize bundle size
- Use React.memo, useMemo, useCallback appropriately

## Code Review Checklist

Before submitting code for review, ensure:

### Security
- [ ] All inputs validated and sanitized
- [ ] No sensitive data in logs
- [ ] Authentication/authorization checks in place
- [ ] SQL injection prevention (using ORM)
- [ ] XSS prevention (output sanitization)

### Code Quality
- [ ] Type hints/TypeScript types used
- [ ] No hardcoded values (use config)
- [ ] **Integration APIs used (no local files/hardcoded configs)**
- [ ] Error handling implemented
- [ ] Code follows naming conventions
- [ ] No commented-out code
- [ ] Functions are focused and testable

### Performance
- [ ] Database queries optimized
- [ ] No N+1 queries
- [ ] Appropriate use of caching
- [ ] Frontend components optimized

### Testing
- [ ] Tests written for new functionality
- [ ] Edge cases covered
- [ ] Error cases tested

### Documentation
- [ ] Public functions documented
- [ ] Complex logic explained
- [ ] API endpoints documented

## Integration Architecture Reference

For integration implementation details, see:
- [INTEGRATIONS_EMAIL_FIX.md](./INTEGRATIONS_EMAIL_FIX.md) - Email service integration implementation
- [TPRM_EMAIL_INTEGRATION.md](./docs/TPRM_EMAIL_INTEGRATION.md) - TPRM email integration guide
- `/api/v1/integrations` - Integration API endpoints
- `/api/v1/smtp-settings` - SMTP settings API (creates Integration records)

## References

For comprehensive coding standards, see:
- [CODING_STANDARDS.md](./CODING_STANDARDS.md) - Detailed coding standards
- [PROJECT_RULES.md](./PROJECT_RULES.md) - Project-specific rules and guidelines
